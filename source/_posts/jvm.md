---
title: jvm
date: 2024-07-01 09:03:39
tags: jvm 虚拟机
---



## jVM内存结构

### 运行时数据区

​	jvm在运行过程中会把他所管理的内存划分成<font color="red">若干</font> 不同的 <font color="red">数据区域</font> ！

​	线程私有： 程序计数器、虚拟机栈、本地方法栈

​	线程共享：堆、方法区

<img src="/images/1719796187750.png" alt="数据类型" />

#### 线程私有区域

程序计数器：指向 当前线程正在执行的字节码指令的地址（行号），唯一不会oom的区域。

​		为什么要有程序计数器？

​		java是多线程的，意味着线程切换，确保多线程情况下的程序正常执行，引入程序计数器。

栈：数据结构，先进后出 ，

​		为什么jvm使用栈？

​		非常好的兼容 方法中调用方法

虚拟机栈：	-Xss 1M  设置大小

​		  存储<font color="red">当前线程</font> 运行  方法  所需的数据，指令，返回地址

​		  每个方法都是一个栈帧

本地方法栈：保存的是当前线程的native方法的信息。

#### 线程共享的区域

方法区（永久代（JDK1.7以前叫法）、元空间（JDK1.8））

​	类信息

​	常量

​	静态变量

​	即时编译期编译后的代码

Java 堆（-Xms：（初始大小）  -Xmx ：（最大）  -Xmm（新生代大小））

​	堆是需要重点关注的一块区域，涉及到内存的分配（new 关键字，反射等）与回收（回收算法，收集器等)

​	堆是内存分配和垃圾回收的重点区域，几乎所有的<font color="red">对象</font> 都是在堆中分配。

## jvm中的对象

#### 	jvm中的对象分配

<img src="/images/1719816227908.png" alt="数据类型" />



#### 对象的内存布局  



<img src="171981716.png" alt="数据类型" />

对象头的大小必须是8个字节的整数

对象头存储：hashcode值，GC垃圾回收（年龄），锁状态标志，线程持有的锁，偏向线程id,偏向时间戳等等。

#### <img src="/images/1719817196796.png" alt="数据类型" />对象的访问方式

<img src="/images/1719817531364.png" alt="数据类型" />



#### 堆内存分配策略

​	堆进一步划分

​		新生代（PSYong Gen）

​			Eden   空间

​			From  survivor空间

​			To  survivor

​		老年代（ParOld Gen）

​	堆中参数设置：

​	新生代大小： -Xmn20m 表示新生代大小20M(初始和最大)

​	-XX:SurvivorRatio=8 表示Eden和Survivor的比值，缺省为8，表示Eden:From:To  =8:1:1

​	-XX:SurvivorRatio=2  表示 Eden:From:To  =2 :1 : 1

<img src="/images/1719818697685.png" alt="数据类型" />

###### 1.对象优先在Eden分配

###### 2.大对象直接进入老年代

<img src="/images/1719820717422.png" alt="数据类型" />

###### 3.长期存活的对象将进入老年代

​		GC通过15次后进入老年代

###### 4.动态对象年龄判断

​		From区俩个对象内存大小占到一半，年龄达到5时，直接进入老年代

###### 5.空间分配担保

​		HandlePromotionFailure：确保每次放入老年代不会发生GC



#### 垃圾回收算法与垃圾回收器











