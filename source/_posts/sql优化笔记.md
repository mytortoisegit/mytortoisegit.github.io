---
title: sql优化笔记
date: 2024-06-11 12:26:36
tags: sql优化
---

SQL优化是提高数据库查询效率、减少查询时间和资源消耗的关键，以下是一些常见的SQL优化方式：



### **1.索引优化**

**1）使用适当的索引**：在查询频繁的列上创建索引，如主键、外键、经常出现在`WHERE`子句和连接条件中的列。 

```sql
-- 1 在where子句列上用索引
-- 假设有一个名为users的表，并在last_name列上创建索引
CREATE INDEX idx_users_lastname ON users(last_name);

-- 我们查询用户的姓氏为"Smith"的记录，可以编写如下SQL语句
-- 这条查询会利用idx_users_lastname索引
SELECT * FROM users WHERE last_name = 'Smith';
-- 在这个查询中，由于last_name列上有索引，数据库可以快速定位到姓氏为"Smith"的记录，而不是扫描整个users表。
-- 2在连接条件中使用索引列	
-- 假设有两个表orders和users，其中orders表中的user_id列是用户的外键，并且在user_id列上创建了索引：
CREATE INDEX idx_orders_userid ON orders(user_id);
-- CREATE INDEX idx_orders_userid ON orders(user_id);
-- 这条查询会利用idx_orders_userid索引
SELECT u.*, o.* 
FROM users u 
JOIN orders o ON u.id = o.user_id;
--在这个查询中，连接条件u.id = o.user_id中的user_id列上有索引，数据库可以利用该索引快速找到对应的用户记录，从而提高连接操作的性能。
```

2）避免过多索引：虽然索引可以加快查询速度，但也会增加插入、更新和删除操作的成本。

```txt
1.每次对表进行以上操作时相关索引都需要同步更新，增加额外开销，2.索引需要在磁盘上占更多空间，增加磁盘使用量，3.过多的索引使得数据库的维护变得更加复杂，增加管理难度，4.数据库查询优化器在进行决策时过多的索引会浪费更多的时间决策，以及可能会选择次优的索引，影响查询效率。
```



3）选择合适的索引类型：如B-tree索引、哈希索引、全文索引等、根据具体查询需求选择合适的索引类型

### 2.查询优化 

 1）使用执行计划EXPLAN分析查询：使用explan分析查询计划

 2）避免全表扫描：尽量使用索引来避免全表扫描

 3) 减少查询的复杂性：分解复杂查询，将其分解为多个简单查询	

 4）选择性的使用子查询和联接：在某些情况下，子查询可以转换为联结查询，或者联结查询转换为子查询

  1、子查询转换为联接 

假设有两个表：`employees` 和 `departments`。`employees` 表存储员工信息，`departments` 表存储部门信息。我们希望找到所有在"Sales"部门工作的员工。 

```sql
-- 子查询方式
SELECT * 
FROM employees 
WHERE department_id = (SELECT id FROM departments WHERE name = 'Sales');
```

在这个查询中，子查询会首先查找部门名称为"Sales"的部门ID，然后外层查询会使用这个ID查找员工。这种方式可能会比较慢，因为需要执行两个查询。 

我们可以将这个子查询转换为联接： 

```sql
-- 联接方式
SELECT e.* 
FROM employees e
JOIN departments d ON e.department_id = d.id
WHERE d.name = 'Sales';
```

使用联接后，数据库可以同时处理两个表的连接，并且通常会更高效，特别是当适当的索引存在时。 

2、联接转换为子查询 

假设我们有一个查询，想找到那些没有在任何订单中出现过的客户。这里有两个表：`customers` 和 `orders`。 

```sql
-- 联接方式
SELECT c.* 
FROM customers c
LEFT JOIN orders o ON c.id = o.customer_id
WHERE o.id IS NULL;
```

在这个查询中，我们使用了左联接来查找没有订单的客户。但如果`orders`表非常大，联接操作可能会非常耗时 。

我们可以将其转换为子查询： 

```sql
-- 子查询方式
SELECT * 
FROM customers 
WHERE id NOT IN (SELECT customer_id FROM orders);
```

这个查询首先执行子查询，找出所有有订单的客户ID，然后在外层查询中过滤掉这些客户。对于某些数据库引擎和数据分布，这种方式可能会更快。 

3. 选择性使用子查询和联接的考虑因素
  性能影响
  索引：联接操作可以更好地利用索引，尤其是在连接条件上有适当的索引时。
  结果集大小：如果子查询返回的结果集较小，将子查询转换为联接可能会更高效。
  数据库优化器：不同数据库的查询优化器对于联接和子查询的处理方式不同，有时需要具体测试以确定哪种方式性能更好。
4. 性能影响

​        **索引**：联接操作可以更好地利用索引，尤其是在连接条件上有适当的索引时。

​       **结果集大小**：如果子查询返回的结果集较小，将子查询转换为联接可能会更高效。

​	**数据库优化器**：不同数据库的查询优化器对于联接和子查询的处理方式不同，有时需要具体测试以确定			哪种方式性能更好。

### 3.表结构优化

1）表规范化和反规范化：根据实际情况适当的选择规范化和反规范化，减少数据冗余和查询复杂度

2）数据分区：将大型表进行分区，提高查询性能和管理效率

3）数据压缩：对历史数据进行压缩存储，以减少存储空间和I/O开销

### 4.硬件和配置优化

1)适当配置数据库参数：调整缓存池大小、连接池大小、缓存设置等数据库配置信息参数

2）增加硬件资源：在必要时增加更多的CPU、内存和磁盘I/O能力

### 5.SQL编写最佳实践

1）避免使用`select *`: 只查询所需要的列，减少数据传输量

2）使用绑定变量：防止SQL注入，提高查询性能

3）合理使用`join`：避免使用过多的`JOIN`，尤其是`cross join`

4）使用批量操作：对于批量插入、更新和删除操作，尽量使用批量操作以减少开销。

5）避免不必要的排序和分组：如非必须，不要使用`order by` 、  `group by`  和 `distinct`

6）使用合适的连接顺序：优化连接顺序，使得结果集比较小的表先参与连接。